; Decrypts a string using a Caesar cipher.
; CSC 225, Assignment 3 

            .ORIG x3000
            
            ; clear all registers before starting 
            AND R0, R0, #0
            AND R1, R1, #0 
            AND R2, R2, #0 
            AND R3, R3, #0 
            AND R4, R4, #0 
            AND R5, R5, #0 
            AND R6, R6, #0 
            AND R7, R7, #0 
            
            
            ;Print out "Encrypted String: "
            LEA R0, ENCRYPT_PROMPT  ; Load the prompt.
            LD  R1, NEW_OFFSET      ; Load a "negative newline" into R1.
            LEA R2, ORIG_STRING     ; Load the address of the string into R2.
            PUTS                    ; Print the prompt.
            
            ; Have the user type the encrypted string to the terminal 
LOOP        GETC                    ; While the user types characters...
                OUT                     ; ...echo the character...
                ADD R4, R0, R1          ; ...and the character...
                BRz DONE                ; ...is not the newline...
                    STR R0, R2, #0          ; ...store the character... 
                    ADD R2, R2, #1          ; ...increment the address...
            BRnzp LOOP              ; ...loop back
            
            ; Start a counter at 9 
DONE        AND R3, R3, #0          ; clear R3
            ADD R3, R3, #9          ; set R3 to 9, the counter 
            
            
            ; Print all possible corresponding unencrypted string - decrypt with each key 
LOOP2       BRn DONE2               ; While the counter is not negative 
                ADD R5, R3, #-9         ; ...subtract 9 from the counter to get decryption key as a negative (9-9=0, 8-9=-1, 7-9=-2, etc.)...
               
                AND R4, R4, #0          ; ...get the null char...
                STR R4, R2, #0          ; ...store the null char...  
                
                LEA R0, DECRYPT_PROMPT  ; ...load the prompt...
                PUTS                    ; ...print the prompt...
               
                NOT R0, R5              ; ...negate R5 to get the decryption key... 
                ADD R0, R0, #1 
               
                ADD R0, R0, #15         ; ...convert the decryption key to the ASCII character...  
                ADD R0, R0, #15
                ADD R0, R0, #15 
                ADD R0, R0, #3 
                OUT                     ; ...print the decryption key...
               
                AND R0, R0, #0          ; ...get the ASCII ':'... 
                ADD R0, R0, #15
                ADD R0, R0, #15 
                ADD R0, R0, #15 
                ADD R0, R0, #13
                OUT                     ; ...print the ':'...
               
                AND R0, R0, #0          ; ...get the ASCII ' '...
                ADD R0, R0, #15 
                ADD R0, R0, #15 
                ADD R0, R0, #2
                OUT                     ; ...print the ' '...
               
               
                LEA R2, DEC_STRING      ; ...load the first address of the DEC_STRING in R2... 
                LEA R6, ORIG_STRING     ; ...load the first address of the ORIG_STRING in R6... 
                LDR R7, R6, #0          ; ...load the value of at the first address of ORIG_STRING...         
LOOP3           BRz DONE3               ; ...while the value of the ORIG_STRING is not zero...
                    
                    AND R0, R0, #0          ; ...set R0 to -31, ASCII 31 becomes unprintable...
                    ADD R0, R0, #-15
                    ADD R0, R0, #-15 
                    ADD R0, R0, #-1 

                    ADD R1, R7, R5          ; ...apply the decryption key...      
                    
                    ; put a '?' character if R1 is 31 or less 
                    ADD R0, R1, R0          ; ...R1 - 31...
                    BRp OFFSET              ; if R1 - 31 > 0 then its a valid character 
                        AND R1, R1, #0          ; ...set R1 to 63, ASCII 63 becomes '?'...
                        ADD R1, R1, #15
                        ADD R1, R1, #15
                        ADD R1, R1, #15
                        ADD R1, R1, #15
                        ADD R1, R1, #3 
                    
OFFSET              STR R1, R2, #0          ; ...store the character... 
                    ADD R6, R6, #1          ; ...increment the address...
                    ADD R2, R2, #1          ; ...increment the address...
                    LDR R7, R6, #0          ; ...get the value of the next address of ORIG_STRING...
                BRnzp LOOP3                 ; ...loop back. 
                 
DONE3           AND R4, R4, #0          ; ...get the null char...
                STR R4, R2, #0          ; ...store the null char...   
                
                LEA R0, DEC_STRING      ; ...load the decrypted string...     
                PUTS                    ; ...print the decrypted string...
                
                AND R0, R0, #0          ; ...get the ASCII '\n'... 
                ADD R0, R0, #13
                OUT                     ; ...print '\n'...
                 
                ADD R3, R3, #-1         ; ...decrement the counter by 1...
                BRnzp LOOP2             ; ...loop back. 

DONE2        HALT                    ; Halt.

NEW_OFFSET  .FILL x-0A ; IDK what this one is for 
ENCRYPT_PROMPT  .STRINGZ "Encrypted string: "
DECRYPT_PROMPT  .STRINGZ "Decryption key "
ORIG_STRING     .BLKW #33 
DEC_STRING      .BLKW #33
                .END
